// Overall program
program: (_top_level_program_line)*

// Types
_value_type: type_name
           | struct_type
           | function_type
ref_type: _type "&" | "(" _type ")" "&"
stack_array_type: _type "[" SIGNED_INT ("," SIGNED_INT)* "]"
heap_array_type: _type "[" "&" ("," SIGNED_INT)* "]"

_type: _value_type | ref_type | stack_array_type | heap_array_type
type: _type
generic_annotation: "<" _inner_list_of_type_names ">"

accessed_variable_name: CNAME
variable_name: CNAME
type_name: CNAME [ generic_annotation ]

_inner_list_of_named_members: variable_name ":" type ("," variable_name ":" type)*
_inner_list_of_types: (type ("," type)*)?
_inner_list_of_type_names: (type_name ("," type_name)*)?
struct_type: "{" _inner_list_of_named_members? "}"

_function_type_component: ("(" (_inner_list_of_named_members | _inner_list_of_types) ")") | type
function_type: _function_type_component "->" _function_type_component

// Symbols
operator: /[.<>%*$@|&\/=?!+-]+/
!bool_constant: "true" | "false"

// Top level
_top_level_program_line: _top_level_program_feature ";"
_top_level_program_feature: typedef
                          | foreign_function
                          | named_function
                          | operator_function
                          | constructor_function
                          | destructor_function
                          | variable_declaration
                          | const_declaration

generic_definition_list: "<" _typedef_name ("," _typedef_name)* ">"
_typedef_name: CNAME
typedef: "typedef" _typedef_name [ generic_definition_list ] ":" type

function_name: CNAME ( generic_annotation )?
function_arguments: "(" (variable_name ":" type ("," variable_name ":" type)*)? ")"
_function_declaration: ":" function_arguments "->" type
_function_definition: _function_declaration "=" scope
foreign_function: "foreign" function_name _function_declaration
named_function: "function" function_name _function_definition
operator_function: "@operator" operator _function_definition
constructor_function: "@constructor" _function_definition
destructor_function: "@destructor" _function_definition

// Local scope
scope: "{" (scope | _line_of_code)* "}"
_control_flow: if_statement
_line_of_code: _line_of_code_without_semi ";"
             | _control_flow
_line_of_code_without_semi: expression
                          | variable_declaration
                          | const_declaration
                          | return_statement
                          | assignment

variable_declaration: "let" variable_name ":" type ["=" expression]
const_declaration: "const" variable_name ":" type "=" expression
return_statement: "return" (_expression)?
assignment: expression "=" expression

condition: _expression
if_statement: "if" "(" condition ")" scope

// We just match python's order of operation
// https://docs.python.org/3/reference/expressions.html#operator-precedence
!_compare_token: "<" | ">" | "==" | ">=" | "<=" | "!="
!_shift_token: "<<" | ">>"
!_add_sub_token: "+" | "-"
!_mult_div_token: "*" | "@" | "/" | "//" | "%"
!_unary_operator_token: "!" | "-" | "+"

// See below for recursive expression defintion
expression: _expression
_expression: logical_or

!?logical_or: logical_and
             | logical_and "||" logical_or -> operator_use
!?logical_and: comparison_op
             | comparison_op "&&" logical_and -> operator_use
!?comparison_op: bitwise_or
               | bitwise_or _compare_token comparison_op -> operator_use
!?bitwise_or: bitwise_xor
            | bitwise_xor "|" bitwise_or -> operator_use
!?bitwise_xor: bitwise_and
             | bitwise_xor "^" bitwise_xor -> operator_use
!?bitwise_and: bit_shift
             | bit_shift "&" bitwise_and -> operator_use
!?bit_shift: add_sub
           | add_sub _shift_token bit_shift -> operator_use
!?add_sub: mult_div
         | mult_div _add_sub_token add_sub -> operator_use
!?mult_div: power
          | power _mult_div_token mult_div -> operator_use
!?power: unary_operator
       | unary_operator "**" power -> operator_use
!?unary_operator: borrow_operator
                | _unary_operator_token unary_operator -> unary_operator_use
?borrow_operator: _non_operator_expression
                | "&" _non_operator_expression -> borrow_operator_use

// TODO: add support for arbitrary operators
//  Alternatively we can prevent user defined operators not in this list

_non_operator_expression: function_call
                        | accessed_variable_name
                        | struct_member_access
                        | array_index_access
                        | "(" expression ")"
                        | named_struct_initialization
                        | adhoc_struct_initialization
                        | ESCAPED_STRING
                        | SIGNED_INT
                        | SIGNED_FLOAT
                        | bool_constant

struct_member_access: _non_operator_expression "." variable_name
array_index_access: _non_operator_expression "["  expression ("," expression)*  "]"

function_call: function_name "(" inner_list_without_names ")"

_inner_list_without_names: (_expression ("," _expression)*)?
inner_list_without_names: _inner_list_without_names
struct_initializer_without_names: _inner_list_without_names

_inner_list_with_names: CNAME ":" _expression ("," CNAME ":" _expression)*
inner_list_with_names: _inner_list_with_names
struct_initializer_with_names: _inner_list_with_names

_adhoc_struct_initialization: "{" (struct_initializer_with_names | struct_initializer_without_names) "}"
adhoc_struct_initialization: _adhoc_struct_initialization

named_struct_initialization: type_name _adhoc_struct_initialization

%ignore C_COMMENT
%ignore CPP_COMMENT
%ignore WS
%import common.C_COMMENT
%import common.CNAME
%import common.CPP_COMMENT
%import common.SIGNED_INT
%import common.SIGNED_FLOAT
%import common.ESCAPED_STRING
%import common.WS
